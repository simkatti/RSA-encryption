# Implementation

I'm interested in cyber security so I wanted to make a project related to cryptography. The process started with research: studying the algorithms and mathematics and planning the program structure. By the time I started coding and building the program, I had a clear idea how to implement it and where to start. The RSA algortihm is based on large prime numbers and their modulus.

Here is quick summary of how RSA works [[1]](https://en.wikipedia.org/wiki/RSA_(cryptosystem)):

- $p$ and $q$  - Two randomly generated prime numbers, each 1024-bits long (approximately 309 digits)
- $n = p \cdot q$ - The 2048-bit modulus
- $\lambda(n) = t = \frac{(p-1) (q-1)}{\gcd(p-1,q-1)}$ - Carmichael's totient function
- $e = 65537$ - Public exponent, where $65537$ is the commonly used value for $e$ so that $1 < e < t$ and $\gcd(e,t) =1$
- $d$ - The private exponent $d$ can be found solving following equation: $de \equiv 1(\mod \lambda(n))$. This can be further rearranged to $d = e^{-1} \mod \lambda(n)$ which makes finding $d$ simple.
- The public key consists of two values: $n$ and $e$
- The private key consists of two values: $n$ and $d$
- Before encryption the message is padded. Padding is done with Optimal asymmetric encryption padding (OAEP) and SHA-256 has function.
- The padded message is encrypted with the public key by first turning it into an integer $m$ and performing modular exponentiation $c = m^e \mod n$, where $c$ is the encrypted message and $e$ and $n$ public key values.
- The encrypted message $c$ can be decrypted back to original text with private key by performing modular exponentation $c^d \mod n$. The result is turned into bytes and unpadded to reveal the message.

## Programs key components

The program has four main components: key generation, encryption, decryption and padding.

### GUI

I started the project with finishing the GUI first. The GUI allows user to input a message of 1-190 bytes. This is the maximum plaintext size with padding that can be encrypted with a 2048-bit RSA key. The GUI also generates a separate txt file where users can find both public and private keys as well as displaying them on the screen. 


### Key generation
Key generation is implemented in keygenerator.py. The module has methods for generating large 1024-bit numbers, generating a list of small prime numbers, Miller-Rabins test for primality and calculating the key components. 

The list of small prime numbers are calculated with the Sieve of Eratosthenes [[2]](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes). I chose to generate 1229 first primes (10000 iterations) for better efficiency. This algorithm starts with a list of numbers (0 to 10,000) and iteratively marks multiples of each prime as False. At the end, the remaining non False values are prime numbers.

Miller-Rabins algorithm starts by factoring out the powers of two from the large prime candidate to get $s$ and $d$, where $s$ is the number of times the number 2 is a factor of $n$ and $d$ is $n$ with all its factors of 2 removed. The algorithm then repeats modular exponentiation $k$ times and returns true if either of the following requirements are continiously met:
1. $a^d ≡ 1 \mod n
2. $a^{2d} ≡ -1 \mod n$

If the first requirement fails the second requirement is tested $s-1$ times or until the second requirement is met. I chose $k=100$ because higher value of k gives higher accuracy whether the $n$ is prime [[3]](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test).

The key values $p$ and $q$ are generated by choosing a random 1024-bit number and making sure it is prime. Checking for primality starts with iterating through the small prime list and checking if the prime candidate is divisible with any of the small primes. If not, the prime candidate goes through Rabin Miller's algorithm. If returned true, the number is likely to be prime.

The other key values are computed as listed above. 

### Encryption
The encryption module receives user input from the GUI. It starts by generating public and private keys and fetching them from the key generator. The message is then sent to the padding module to be padded. The padded message is encrypted using modular exponentation. The component returns an encrypted message, public key, and private key back to the GUI where they are displayed to the user. 

### Decryption
The decryption module works similarly to encryption but in reverse. First, modular exponentiation is performed to decrypt the message. Then, the resulting integer is sent to the padding module in byte format to be unpadded. The returned byte string is decoded into ascii string and the decrypted message is returned back to the GUI for display to the user.

### Padding
Padding was a last minute feature I added. It is implemented using Optimal Asymmetric Encryption Padding with the SHA-256 hash function. The padding module works by taking the plain user input as a the message to be padded. The key components include the mask generation function, the hash function and the xor-operation. The mask generation function works by concatenating hashed return values into a byte string of the given length [[4]](https://en.m.wikipedia.org/wiki/Mask_generation_function).

The padding steps [[5]](https://en.m.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding):
1. Hashing L-label: an empty byte string is hashed using the SHA-256 hash function
2. Generating a padding string: a byte string of 0x00 is created with length $k - mLen - 2 \cdot hLen -2$ , where
   - $k$ is length of modulus $n$ in bytes,
   - $mLen$ is length of the message in bytes
   - $hLen$ is the length of hashed L-label
4. Forming the datablock: The data block is formed by concatenating the hashed label, the padding string, a single byte 0x01, and the message
5. Generating a random seed
6. Generating datablock mask: this is done using the mask generation function, which takes the seed and length $k - hLen - 1$
7. Masking the datablock: The data block and its mask is sent to the XOR method
8. Generating seed mask: this is done using the mask generation function which takes takes the masked datablock and length $hLen$
9. Masking the seed: The seed and seed mask is sent to the XOR method
10. The padded message is concatenation of 0x00, masked seed and masked datablock

The unpadding has the same steps but in reverse to find the encrypted message m. 

## Time and space complexity
The most consuming task is Miller-Rabins primality test with the time complexity of O(k log³ n) where k is the number of rounds and n is the number being tested. The space complexity is O(n) where n is the bit length of the primes.

## Potential improvements
I'm sure there is lot of things to improve in terms of the code, structure, time complexity and functions. One overall improvement is the program could be adding options for different size keys as the limitation currently is 2048-bits. 

## Use of AI
AI (ChatGPT) has been used while working on this project. The AI has been used mainly for debugging the code. 

## References
[RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem))

[Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)

[Rabin Miller](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test)

[Carmichael function](https://en.wikipedia.org/wiki/Carmichael_function)

[Mask Generation Function](https://en.m.wikipedia.org/wiki/Mask_generation_function)

[Optimal Asymmetric Encryption Padding](https://en.m.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding)
