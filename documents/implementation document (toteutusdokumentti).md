<!-- Toteutusdokumentin tulee sisältää seuraavat:

Ohjelman yleisrakenne
Saavutetut aika- ja tilavaativuudet (esim. O-analyysit pseudokoodista)
Suorituskyky- ja O-analyysivertailu (mikäli sopii työn aiheeseen)
Työn mahdolliset puutteet ja parannusehdotukset
Laajojen kielimallien (ChatGPT yms.) käyttö. Mainitse mitä mallia on käytetty ja miten. Mainitse myös mikäli et ole käyttänyt. Tämä on tärkeää!
Lähteet, joita olet käyttänyt, vain ne joilla oli merkitystä työn kannalta. -->

# Implementation

I'm interested in cyber security so I wanted to make a project related to cryptography. The process started with research: studying the algorithms and mathematics and planning the program structure. By the time I started coding and building the program, I had a clear idea how to implement it and where to start. The RSA algortihm is based on large prime numbers and their modulus.

Here is quick summary of how RSA works [[1]](https://en.wikipedia.org/wiki/RSA_(cryptosystem)):

- $p$ and $q$  - Two randomly generated prime numbers, each 1024-bits long (approximately 309 digits)
- $n = p \cdot q$ - The 2048-bit modulus
- $\lambda(n) = t = \frac{(p-1) (q-1)}{\gcd(p-1,q-1)}$ - Carmichael's totient function
- $e = 65537$ - Public exponent, where $65537$ is the commonly used value for $e$ so that $1 < e < t$ and $\gcd(e,t) =1$
- $d$ - The private exponent $d$ can be found solving following equation: $de \equiv 1(\mod \lambda(n))$. This can be further rearranged to $d = e^{-1} \mod \lambda(n)$ which makes finding $d$ simple.
- The public key consists of two values: $n$ and $e$
- The private key consists of two values: $n$ and $d$
- The message is encrypted with the public key by first turning it into integer $m$ and performing modular exponentiation $c = m^e \mod n$, where $c$ is the encrypted message and $e$ and $n$ public key values.
- The encrypted message $c$ can be decrypted back to original text with private key by performing modular exponentation $c^d \mod n$

## Programs key components

The program has three main components: key generation, encryption and decryption.

### GUI

I started the project with finishing the GUI first. The GUI allows user to input a message of 1- 256 characters. This is the maximum plaintext size that can be encrypted with a 2048-bit RSA key [[2]](https://mbed-tls.readthedocs.io/en/latest/kb/cryptography/rsa-encryption-maximum-data-size/).


### Key generation
Key generation is implemented in keygenerator.py. The module has methods for generating large 1024-bit numbers, generating a list of small prime numbers, Miller-Rabins test for primality and calculating the key components. 

The list of small prime numbers are calculated with the Sieve of Eratosthenes [[3]](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes). I chose to generate 1229 first primes (10000 iterations) for better efficiency. This algorithm starts with a list of numbers (0 to 10,000) and iteratively marks multiples of each prime as False. At the end, the remaining non False values are prime numbers.

Miller-Rabins algorithm starts by factoring out the powers of two from the large prime candidate and then repeating modular exponentiation until requirement $n - 1 \equiv -1 \mod n$ is met. I chose k=100 because higher value of k gives higher accuracy weather the $n$ is prime [[4]](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test).

The key values $p$ and $q$ are generated by choosing a random 1024-bit number and making sure it is prime. Checking for primality starts with iterating through the small prime list and checking if the prime candidate is divisible with any of the small primes. If not, the prime candidate goes through Rabin Miller's algorithm. If returned true, the number is likely to be prime.

The other key values are computed like listed above. 

### Encryption
he encryption module receives user input from the GUI. It starts by transforming the plaintext message into an integer and then fetches the public and private keys from the key generator. The message is encrypted using modular exponentiation. The component returns the encrypted message, public key, and private key back to the GUI, where they are displayed to the user.

### Decryption
The decryption module works similarly to encryption but in reverse. First, modular exponentiation is performed to decrypt the message. Then, the resulting integer is converted back into text. The decrypted message is returned to the GUI for display to the user.


## Time and space complexity

## Potential improvements

## Use of AI
